// Generated by CoffeeScript 1.12.7
(function() {
  var VERSION, config, configPath, emptyHeaders, endParams, endReqOpts, flush, fs, http, https, httpsPattern, log, pixel, pixelHeaders, protocol, protocolOptions, querystring, record, reset, serialize, server, store, url;

  fs = require('fs');

  url = require('url');

  http = require('http');

  https = require('https');

  querystring = require('querystring');

  VERSION = '0.1.4';

  httpsPattern = new RegExp('^https://', 'i');

  store = {};

  record = function(params) {
    var key, ref;
    if (!(key = (ref = params.query) != null ? ref.key : void 0)) {
      return;
    }
    store[key] || (store[key] = 0);
    return store[key] += 1;
  };

  serialize = function() {
    var data;
    data = {
      json: JSON.stringify(store)
    };
    if (config.secret) {
      data.secret = config.secret;
    }
    return querystring.stringify(data);
  };

  reset = function() {
    return store = {};
  };

  flush = function() {
    var data, endpointProtocol, request;
    log(store);
    if (!config.endpoint) {
      return;
    } else if (httpsPattern.test(config.endpoint)) {
      endpointProtocol = https;
    } else {
      endpointProtocol = http;
    }
    data = serialize();
    endReqOpts['headers']['Content-Length'] = data.length;
    request = endpointProtocol.request(endReqOpts, function(response) {
      reset();
      return console.info('--- flushed ---');
    });
    request.on('error', function(e) {
      if (config.discard) {
        reset();
      }
      return console.log("--- cannot connect to endpoint : " + e.message);
    });
    request.write(data);
    return request.end();
  };

  log = function(hash) {
    var hits, key, results;
    results = [];
    for (key in hash) {
      hits = hash[key];
      results.push(console.info(hits + ":\t" + key));
    }
    return results;
  };

  configPath = process.argv[2];

  if (configPath === '-v' || configPath === '-version' || configPath === '--version') {
    console.log("Pixel Ping version " + VERSION);
    process.exit(0);
  }

  if (!configPath || (configPath === '-h' || configPath === '-help' || configPath === '--help')) {
    console.error("Usage: pixel-ping path/to/config.json");
    process.exit(0);
  }

  config = JSON.parse(fs.readFileSync(configPath).toString());

  pixel = fs.readFileSync(__dirname + '/pixel.gif');

  pixelHeaders = {
    'Cache-Control': 'private, no-cache, proxy-revalidate, max-age=0',
    'Content-Type': 'image/gif',
    'Content-Disposition': 'inline',
    'Content-Length': pixel.length
  };

  emptyHeaders = {
    'Content-Type': 'text/html',
    'Content-Length': '0'
  };

  if (config.endpoint) {
    console.info("Flushing hits to " + config.endpoint);
    endParams = url.parse(config.endpoint);
    endReqOpts = {
      host: endParams.hostname,
      port: endParams.port || 80,
      method: 'POST',
      path: endParams.pathname,
      headers: {
        'host': endParams.host,
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    };
  } else {
    console.warn("No endpoint set. Hits won't be flushed, add \"endpoint\" to " + configPath + ".");
  }

  process.on('SIGUSR2', function() {
    console.log('Got SIGUSR2. Forcing a flush:');
    return flush();
  });

  process.on('uncaughtException', function(err) {
    return console.error("Uncaught Exception: " + err);
  });

  if (config.sslkey && config.sslcert && config.sslca) {
    protocol = https;
    protocolOptions = {
      key: fs.readFileSync(config.sslkey),
      cert: fs.readFileSync(config.sslcert),
      ca: fs.readFileSync(config.sslca)
    };
  } else if (config.sslkey && config.sslcert) {
    protocol = https;
    protocolOptions = {
      key: fs.readFileSync(config.sslkey),
      cert: fs.readFileSync(config.sslcert)
    };
  } else {
    protocol = http;
  }

  server = protocol.createServer(protocolOptions, function(req, res) {
    var params;
    params = url.parse(req.url, true);
    if (params.pathname === '/pixel.gif') {
      res.writeHead(200, pixelHeaders);
      res.end(pixel);
      record(params);
    } else {
      res.writeHead(404, emptyHeaders);
      res.end('');
    }
    return null;
  });

  server.listen(config.port, config.host);

  setInterval(flush, config.interval * 1000);

}).call(this);
